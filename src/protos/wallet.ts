/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.27.2
 * source: wallet.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export class CreateAddressRequest extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {}) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") { }
    }
    static fromObject(data: {}): CreateAddressRequest {
        const message = new CreateAddressRequest({});
        return message;
    }
    toObject() {
        const data: {} = {};
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CreateAddressRequest {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CreateAddressRequest();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CreateAddressRequest {
        return CreateAddressRequest.deserialize(bytes);
    }
}
export class CreateAddressResponse extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        address?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("address" in data && data.address != undefined) {
                this.address = data.address;
            }
        }
    }
    get address() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set address(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        address?: string;
    }): CreateAddressResponse {
        const message = new CreateAddressResponse({});
        if (data.address != null) {
            message.address = data.address;
        }
        return message;
    }
    toObject() {
        const data: {
            address?: string;
        } = {};
        if (this.address != null) {
            data.address = this.address;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.address.length)
            writer.writeString(1, this.address);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CreateAddressResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CreateAddressResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.address = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CreateAddressResponse {
        return CreateAddressResponse.deserialize(bytes);
    }
}
export class TransactionRequest extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        toAddress?: string;
        points?: number;
        metadata?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("toAddress" in data && data.toAddress != undefined) {
                this.toAddress = data.toAddress;
            }
            if ("points" in data && data.points != undefined) {
                this.points = data.points;
            }
            if ("metadata" in data && data.metadata != undefined) {
                this.metadata = data.metadata;
            }
        }
    }
    get toAddress() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set toAddress(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get points() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set points(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get metadata() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set metadata(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
        toAddress?: string;
        points?: number;
        metadata?: string;
    }): TransactionRequest {
        const message = new TransactionRequest({});
        if (data.toAddress != null) {
            message.toAddress = data.toAddress;
        }
        if (data.points != null) {
            message.points = data.points;
        }
        if (data.metadata != null) {
            message.metadata = data.metadata;
        }
        return message;
    }
    toObject() {
        const data: {
            toAddress?: string;
            points?: number;
            metadata?: string;
        } = {};
        if (this.toAddress != null) {
            data.toAddress = this.toAddress;
        }
        if (this.points != null) {
            data.points = this.points;
        }
        if (this.metadata != null) {
            data.metadata = this.metadata;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.toAddress.length)
            writer.writeString(1, this.toAddress);
        if (this.points != 0)
            writer.writeInt32(2, this.points);
        if (this.metadata.length)
            writer.writeString(3, this.metadata);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TransactionRequest {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TransactionRequest();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.toAddress = reader.readString();
                    break;
                case 2:
                    message.points = reader.readInt32();
                    break;
                case 3:
                    message.metadata = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): TransactionRequest {
        return TransactionRequest.deserialize(bytes);
    }
}
export class TransactionResponse extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        transaction_id?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("transaction_id" in data && data.transaction_id != undefined) {
                this.transaction_id = data.transaction_id;
            }
        }
    }
    get transaction_id() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set transaction_id(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        transaction_id?: number;
    }): TransactionResponse {
        const message = new TransactionResponse({});
        if (data.transaction_id != null) {
            message.transaction_id = data.transaction_id;
        }
        return message;
    }
    toObject() {
        const data: {
            transaction_id?: number;
        } = {};
        if (this.transaction_id != null) {
            data.transaction_id = this.transaction_id;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.transaction_id != 0)
            writer.writeInt64(1, this.transaction_id);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TransactionResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TransactionResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.transaction_id = reader.readInt64();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): TransactionResponse {
        return TransactionResponse.deserialize(bytes);
    }
}
export class BalanceRequest extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        address?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("address" in data && data.address != undefined) {
                this.address = data.address;
            }
        }
    }
    get address() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set address(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        address?: string;
    }): BalanceRequest {
        const message = new BalanceRequest({});
        if (data.address != null) {
            message.address = data.address;
        }
        return message;
    }
    toObject() {
        const data: {
            address?: string;
        } = {};
        if (this.address != null) {
            data.address = this.address;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.address.length)
            writer.writeString(1, this.address);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BalanceRequest {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BalanceRequest();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.address = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): BalanceRequest {
        return BalanceRequest.deserialize(bytes);
    }
}
export class BalanceResponse extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        total?: number;
        available?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("total" in data && data.total != undefined) {
                this.total = data.total;
            }
            if ("available" in data && data.available != undefined) {
                this.available = data.available;
            }
        }
    }
    get total() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set total(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get available() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set available(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        total?: number;
        available?: number;
    }): BalanceResponse {
        const message = new BalanceResponse({});
        if (data.total != null) {
            message.total = data.total;
        }
        if (data.available != null) {
            message.available = data.available;
        }
        return message;
    }
    toObject() {
        const data: {
            total?: number;
            available?: number;
        } = {};
        if (this.total != null) {
            data.total = this.total;
        }
        if (this.available != null) {
            data.available = this.available;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.total != 0)
            writer.writeInt64(1, this.total);
        if (this.available != 0)
            writer.writeInt64(2, this.available);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BalanceResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BalanceResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.total = reader.readInt64();
                    break;
                case 2:
                    message.available = reader.readInt64();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): BalanceResponse {
        return BalanceResponse.deserialize(bytes);
    }
}
export class WalletInfoRequest extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        address?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("address" in data && data.address != undefined) {
                this.address = data.address;
            }
        }
    }
    get address() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set address(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        address?: string;
    }): WalletInfoRequest {
        const message = new WalletInfoRequest({});
        if (data.address != null) {
            message.address = data.address;
        }
        return message;
    }
    toObject() {
        const data: {
            address?: string;
        } = {};
        if (this.address != null) {
            data.address = this.address;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.address.length)
            writer.writeString(1, this.address);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): WalletInfoRequest {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new WalletInfoRequest();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.address = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): WalletInfoRequest {
        return WalletInfoRequest.deserialize(bytes);
    }
}
export class WalletInfoResponse extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        total?: number;
        available?: number;
        transactions?: Transaction[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("total" in data && data.total != undefined) {
                this.total = data.total;
            }
            if ("available" in data && data.available != undefined) {
                this.available = data.available;
            }
            if ("transactions" in data && data.transactions != undefined) {
                this.transactions = data.transactions;
            }
        }
    }
    get total() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set total(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get available() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set available(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get transactions() {
        return pb_1.Message.getRepeatedWrapperField(this, Transaction, 3) as Transaction[];
    }
    set transactions(value: Transaction[]) {
        pb_1.Message.setRepeatedWrapperField(this, 3, value);
    }
    static fromObject(data: {
        total?: number;
        available?: number;
        transactions?: ReturnType<typeof Transaction.prototype.toObject>[];
    }): WalletInfoResponse {
        const message = new WalletInfoResponse({});
        if (data.total != null) {
            message.total = data.total;
        }
        if (data.available != null) {
            message.available = data.available;
        }
        if (data.transactions != null) {
            message.transactions = data.transactions.map(item => Transaction.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            total?: number;
            available?: number;
            transactions?: ReturnType<typeof Transaction.prototype.toObject>[];
        } = {};
        if (this.total != null) {
            data.total = this.total;
        }
        if (this.available != null) {
            data.available = this.available;
        }
        if (this.transactions != null) {
            data.transactions = this.transactions.map((item: Transaction) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.total != 0)
            writer.writeInt64(1, this.total);
        if (this.available != 0)
            writer.writeInt64(2, this.available);
        if (this.transactions.length)
            writer.writeRepeatedMessage(3, this.transactions, (item: Transaction) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): WalletInfoResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new WalletInfoResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.total = reader.readInt64();
                    break;
                case 2:
                    message.available = reader.readInt64();
                    break;
                case 3:
                    reader.readMessage(message.transactions, () => pb_1.Message.addToRepeatedWrapperField(message, 3, Transaction.deserialize(reader), Transaction));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): WalletInfoResponse {
        return WalletInfoResponse.deserialize(bytes);
    }
}
export class Transaction extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        to_address?: string;
        points?: number;
        metadata?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("to_address" in data && data.to_address != undefined) {
                this.to_address = data.to_address;
            }
            if ("points" in data && data.points != undefined) {
                this.points = data.points;
            }
            if ("metadata" in data && data.metadata != undefined) {
                this.metadata = data.metadata;
            }
        }
    }
    get to_address() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set to_address(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get points() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set points(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get metadata() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set metadata(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
        to_address?: string;
        points?: number;
        metadata?: string;
    }): Transaction {
        const message = new Transaction({});
        if (data.to_address != null) {
            message.to_address = data.to_address;
        }
        if (data.points != null) {
            message.points = data.points;
        }
        if (data.metadata != null) {
            message.metadata = data.metadata;
        }
        return message;
    }
    toObject() {
        const data: {
            to_address?: string;
            points?: number;
            metadata?: string;
        } = {};
        if (this.to_address != null) {
            data.to_address = this.to_address;
        }
        if (this.points != null) {
            data.points = this.points;
        }
        if (this.metadata != null) {
            data.metadata = this.metadata;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.to_address.length)
            writer.writeString(1, this.to_address);
        if (this.points != 0)
            writer.writeInt32(2, this.points);
        if (this.metadata.length)
            writer.writeString(3, this.metadata);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Transaction {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Transaction();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.to_address = reader.readString();
                    break;
                case 2:
                    message.points = reader.readInt32();
                    break;
                case 3:
                    message.metadata = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Transaction {
        return Transaction.deserialize(bytes);
    }
}
interface GrpcUnaryServiceInterface<P, R> {
    (message: P, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    (message: P, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    (message: P, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
}
interface GrpcStreamServiceInterface<P, R> {
    (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
    (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
}
interface GrpWritableServiceInterface<P, R> {
    (metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    (metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    (options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
}
interface GrpcChunkServiceInterface<P, R> {
    (metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
    (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
}
interface GrpcPromiseServiceInterface<P, R> {
    (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): Promise<R>;
    (message: P, options?: grpc_1.CallOptions): Promise<R>;
}
export abstract class UnimplementedWalletService {
    static definition = {
        createAddress: {
            path: "/Wallet/createAddress",
            requestStream: false,
            responseStream: false,
            requestSerialize: (message: CreateAddressRequest) => Buffer.from(message.serialize()),
            requestDeserialize: (bytes: Buffer) => CreateAddressRequest.deserialize(new Uint8Array(bytes)),
            responseSerialize: (message: CreateAddressResponse) => Buffer.from(message.serialize()),
            responseDeserialize: (bytes: Buffer) => CreateAddressResponse.deserialize(new Uint8Array(bytes))
        },
        transaction: {
            path: "/Wallet/transaction",
            requestStream: false,
            responseStream: false,
            requestSerialize: (message: TransactionRequest) => Buffer.from(message.serialize()),
            requestDeserialize: (bytes: Buffer) => TransactionRequest.deserialize(new Uint8Array(bytes)),
            responseSerialize: (message: TransactionResponse) => Buffer.from(message.serialize()),
            responseDeserialize: (bytes: Buffer) => TransactionResponse.deserialize(new Uint8Array(bytes))
        },
        balance: {
            path: "/Wallet/balance",
            requestStream: false,
            responseStream: false,
            requestSerialize: (message: BalanceRequest) => Buffer.from(message.serialize()),
            requestDeserialize: (bytes: Buffer) => BalanceRequest.deserialize(new Uint8Array(bytes)),
            responseSerialize: (message: BalanceResponse) => Buffer.from(message.serialize()),
            responseDeserialize: (bytes: Buffer) => BalanceResponse.deserialize(new Uint8Array(bytes))
        },
        walletInfo: {
            path: "/Wallet/walletInfo",
            requestStream: false,
            responseStream: false,
            requestSerialize: (message: WalletInfoRequest) => Buffer.from(message.serialize()),
            requestDeserialize: (bytes: Buffer) => WalletInfoRequest.deserialize(new Uint8Array(bytes)),
            responseSerialize: (message: WalletInfoResponse) => Buffer.from(message.serialize()),
            responseDeserialize: (bytes: Buffer) => WalletInfoResponse.deserialize(new Uint8Array(bytes))
        }
    };
    [method: string]: grpc_1.UntypedHandleCall;
    abstract createAddress(call: grpc_1.ServerUnaryCall<CreateAddressRequest, CreateAddressResponse>, callback: grpc_1.sendUnaryData<CreateAddressResponse>): void;
    abstract transaction(call: grpc_1.ServerUnaryCall<TransactionRequest, TransactionResponse>, callback: grpc_1.sendUnaryData<TransactionResponse>): void;
    abstract balance(call: grpc_1.ServerUnaryCall<BalanceRequest, BalanceResponse>, callback: grpc_1.sendUnaryData<BalanceResponse>): void;
    abstract walletInfo(call: grpc_1.ServerUnaryCall<WalletInfoRequest, WalletInfoResponse>, callback: grpc_1.sendUnaryData<WalletInfoResponse>): void;
}
export class WalletClient extends grpc_1.makeGenericClientConstructor(UnimplementedWalletService.definition, "Wallet", {}) {
    constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
        super(address, credentials, options);
    }
    createAddress: GrpcUnaryServiceInterface<CreateAddressRequest, CreateAddressResponse> = (message: CreateAddressRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<CreateAddressResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<CreateAddressResponse>, callback?: grpc_1.requestCallback<CreateAddressResponse>): grpc_1.ClientUnaryCall => {
        return super.createAddress(message, metadata, options, callback);
    };
    transaction: GrpcUnaryServiceInterface<TransactionRequest, TransactionResponse> = (message: TransactionRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<TransactionResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<TransactionResponse>, callback?: grpc_1.requestCallback<TransactionResponse>): grpc_1.ClientUnaryCall => {
        return super.transaction(message, metadata, options, callback);
    };
    balance: GrpcUnaryServiceInterface<BalanceRequest, BalanceResponse> = (message: BalanceRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<BalanceResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<BalanceResponse>, callback?: grpc_1.requestCallback<BalanceResponse>): grpc_1.ClientUnaryCall => {
        return super.balance(message, metadata, options, callback);
    };
    walletInfo: GrpcUnaryServiceInterface<WalletInfoRequest, WalletInfoResponse> = (message: WalletInfoRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<WalletInfoResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<WalletInfoResponse>, callback?: grpc_1.requestCallback<WalletInfoResponse>): grpc_1.ClientUnaryCall => {
        return super.walletInfo(message, metadata, options, callback);
    };
}
